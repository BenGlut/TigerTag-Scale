<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TigerTag-Scale</title>
    <style>
* { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
}

body { 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #fff;
    padding: 20px;
    min-height: 100vh;
}

.container { 
    max-width: 600px; 
    margin: 0 auto; 
    background: rgba(255,255,255,0.1);
    border-radius: 15px;
    padding: 30px;
    backdrop-filter: blur(10px);
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

h1 { 
    text-align: center; 
    margin-bottom: 30px; 
    font-size: 2em; 
}

.cloud-row { 
    text-align: center; 
    margin: -10px 0 20px 0; 
    opacity: 0.95; 
}

.cloud-dot { 
    display: inline-block; 
    width: 10px; 
    height: 10px; 
    border-radius: 50%; 
    margin-left: 8px; 
    vertical-align: middle; 
    background: #bbb; 
}

/* Both class names are supported for green/up to match JS usage */
.cloud-ok, .cloud-up { 
    background: #2ecc71 !important; 
}

.cloud-down { 
    background: #e74c3c !important; 
}

.card { 
    background: rgba(255,255,255,0.2);
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 20px;
}

.card h2 {
    margin-bottom: 15px;
    font-size: 1.3em;
}

.weight { 
    font-size: 3em; 
    text-align: center; 
    margin: 20px 0; 
    font-weight: bold;
}

.uid { 
    text-align: center; 
    font-size: 1.2em; 
    opacity: 0.9; 
}

input, button { 
    width: 100%;
    padding: 12px;
    margin: 10px 0;
    border-radius: 8px;
    border: none;
    font-size: 1em;
}

button { 
    background: #fff;
    color: #667eea;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s;
}

button:hover { 
    transform: scale(1.05); 
    box-shadow: 0 5px 15px rgba(255,255,255,0.3);
}

button.danger { 
    background: #e74c3c; 
    color: #fff; 
}

button.danger:hover {
    background: #c0392b;
}

.info { 
    text-align: center; 
    opacity: 0.8; 
    margin-top: 10px; 
    font-size: 0.9em;
}

/* Responsive */
@media (max-width: 640px) {
    .container {
        padding: 20px;
    }
    
    h1 {
        font-size: 1.5em;
    }
    
    .weight {
        font-size: 2.5em;
    }
}
</style>
</head>
<body>
    <div class="container">
        <div class="header-row" style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap">
            <h1 style="margin:0;">TigerTag SScale</h1>
            <div id="userNameDisplay" style="font-size:1rem; font-weight:500; color:#555;">User: <span id="userDisplayTitle">—</span></div>
            <div id="userBar" style="display:flex; align-items:center; gap:8px; font-size:0.95rem;">
                <span id="userLabel">User:</span>
                <strong id="userDisplay">—</strong>
                <span id="apiDot" class="cloud-dot cloud-down" title="API Key status"></span>
                <span id="apiStatusText">API key not validated</span>
            </div>
        </div>
        <div class="cloud-row">Cloud: <span id="cloudState">unknown</span><span id="cloudDot" class="cloud-dot"></span></div>
        
        <div class="card">
            <h2>Current weight <span id="wsDot" class="cloud-dot cloud-down" title="WebSocket status"></span></h2>
            <div class="weight" id="weight">-- g</div>
            <div class="uid" id="uid">No tag detected</div>
        </div>
        
        <div class="card">
            <h2>API Key</h2>
            <input type="text" id="newApiKey" placeholder="New API Key" value="">
            <button onclick="updateApiKey()">Update</button>
        </div>

        <div class="card">
            <h2>Send weight to TigerTag</h2>
            <input type="number" id="manualWeight" placeholder="Weight in grams (integer)" inputmode="numeric" step="1">
            <button onclick="sendWeight()">Send</button>
            <div class="info">Uses current UID read by the RFID scanner</div>
        </div>

        <div class="card">
            <h2>Calibrate scale</h2>
            <div class="info">Current factor: <span id="calFactor">—</span></div>
            <input type="number" id="newCalFactor" placeholder="Calibration factor" inputmode="decimal" step="0.1">
            <div style="display:flex; gap:10px">
                <button onclick="tareScale()">Tare</button>
                <button onclick="updateCalibration()">Update factor</button>
            </div>
        </div>
        
        <div class="card">
            <h2>Auto-calc factor</h2>
            <div class="info">Place a known weight, wait for the reading to stabilize, then compute.</div>
            <input type="number" id="knownWeight" placeholder="Known weight (g)" inputmode="decimal" step="0.1">
            <button onclick="computeFactor()">Compute from reading</button>
            <div class="info" id="calcHint">Formula: new = current × (displayed / known)</div>
        </div>
        
        <div class="card">
            <h2>Change Wi‑Fi network</h2>
            <button onclick="resetWiFi()">Reconfigure Wi‑Fi</button>
            <div class="info">Restarts captive portal</div>
        </div>
        
        <div class="card">
            <h2>Factory reset</h2>
            <button class="danger" onclick="factoryReset()">Factory Reset</button>
            <div class="info">Erases all data</div>
        </div>
    </div>
    
    <script>
const wsDot = document.getElementById('wsDot');
const cloudDot = document.getElementById('cloudDot');
const cloudState = document.getElementById('cloudState');
const weightEl = document.getElementById('weight');
const uidEl = document.getElementById('uid');
const calFactorEl = document.getElementById('calFactor');

let ws;
let currentWeight = null;
let currentUid = null;
let calFactor = null;
let apiKey = '';

// --- Minimal DOM diff helpers (avoid unnecessary reflows) ---
function setTextIfChanged(el, next) {
    if (!el) return;
    const cur = el.textContent;
    if (cur !== String(next)) el.textContent = String(next);
}
function toggleClass(el, addCls, removeCls) {
    if (!el) return;
    let changed = false;
    if (addCls && !el.classList.contains(addCls)) { el.classList.add(addCls); changed = true; }
    if (removeCls && el.classList.contains(removeCls)) { el.classList.remove(removeCls); changed = true; }
    return changed;
}

// --- API Key validation (calls external endpoint) ---
const API_PING_BASE = 'https://cdn.tigertag.io/pingbyapikey?key=';
let apiValidateTimer = null;

function setApiStatus(valid, displayName = '') {
    const dot = document.getElementById('apiDot');
    const txt = document.getElementById('apiStatusText');
    const user = document.getElementById('userDisplay');
    const userTitle = document.getElementById('userDisplayTitle');
    if (valid) {
        toggleClass(dot, 'cloud-up', 'cloud-down');
        setTextIfChanged(txt, 'API key valid');
        if (displayName) {
            setTextIfChanged(user, displayName);
            if (userTitle) setTextIfChanged(userTitle, displayName);
        }
    } else {
        toggleClass(dot, 'cloud-down', 'cloud-up');
        setTextIfChanged(txt, 'API key invalid');
        if (!displayName) {
            setTextIfChanged(user, '—');
            if (userTitle) setTextIfChanged(userTitle, '—');
        }
    }
}

function validateApiKey(key) {
    if (!key || typeof key !== 'string') { setApiStatus(false); return; }
    // Debounce calls to avoid spamming the endpoint when typing
    if (apiValidateTimer) clearTimeout(apiValidateTimer);
    apiValidateTimer = setTimeout(() => {
        fetch(API_PING_BASE + encodeURIComponent(key), { method: 'GET', mode: 'cors', cache: 'no-store' })
            .then(r => r.ok ? r.json() : Promise.reject(r.status))
            .then(j => {
                if (j && j.success) {
                    setApiStatus(true, j.displayName || '');
                } else {
                    setApiStatus(false);
                }
            })
            .catch(() => setApiStatus(false));
    }, 250);
}

// Met à jour l'indicateur visuel de connexion WebSocket
function setWsStatus(connected) {
    if (connected) {
        toggleClass(wsDot, 'cloud-up', 'cloud-down');
    } else {
        toggleClass(wsDot, 'cloud-down', 'cloud-up');
    }
}

// Met à jour l'état de connexion au cloud et son indicateur visuel
function setCloudStatus(status) {
    const isUp = (status === 'connected' || status === 'ok' || status === true);
    setTextIfChanged(cloudState, isUp ? 'connected' : (status || 'down'));
    if (isUp) {
        toggleClass(cloudDot, 'cloud-up', 'cloud-down');
    } else {
        toggleClass(cloudDot, 'cloud-down', 'cloud-up');
    }
}

// Établit la connexion WebSocket et gère les événements associés
function connectWs() {
    ws = new WebSocket(`ws://${location.host}/ws`);

    ws.onopen = () => {
        setWsStatus(true);
        console.log('WebSocket connected');
    };

    ws.onclose = () => {
        setWsStatus(false);
        console.log('WebSocket disconnected, retrying in 3s...');
        setTimeout(connectWs, 3000);
    };

    ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (msg.type === 'weight') {
            if (currentWeight !== msg.value) {
                currentWeight = msg.value;
                setTextIfChanged(weightEl, `${currentWeight} g`);
            }
        } else if (msg.type === 'uid') {
            const nextUid = msg.value || '';
            if (currentUid !== nextUid) {
                currentUid = nextUid;
                setTextIfChanged(uidEl, currentUid ? currentUid : 'No tag detected');
            }
        } else if (msg.type === 'calFactor') {
            const next = msg.value;
            if (calFactor !== next) {
                calFactor = next;
                const shown = (calFactor !== null && !isNaN(calFactor)) ? Number(calFactor).toFixed(2) : '—';
                setTextIfChanged(calFactorEl, shown);
            }
        } else if (msg.type === 'cloud') {
            setCloudStatus(msg.value);
        } else if (msg.type === 'apiKey') {
            const nextKey = msg.value || '';
            if (apiKey !== nextKey) {
                apiKey = nextKey;
                const input = document.getElementById('newApiKey');
                if (input && input.value !== apiKey) input.value = apiKey;
            }
        } else if (msg.type === 'apiStatus') {
            // Firmware reports API key validation result
            setApiStatus(!!msg.valid, msg.displayName || '');
        } else {
            // Fallback: handle snapshots without type (weight, uid, cal factor, cloud, apiKey)
            if (typeof msg.weight !== 'undefined' && currentWeight !== msg.weight) {
                currentWeight = msg.weight;
                setTextIfChanged(weightEl, `${currentWeight} g`);
            }
            if (typeof msg.uid !== 'undefined') {
                const nextUid = msg.uid || '';
                if (currentUid !== nextUid) {
                    currentUid = nextUid;
                    setTextIfChanged(uidEl, currentUid ? currentUid : 'No tag detected');
                }
            }
            if (typeof msg.calibrationFactor !== 'undefined') {
                const next = msg.calibrationFactor;
                if (calFactor !== next) {
                    calFactor = next;
                    const shown = (calFactor !== null && !isNaN(calFactor)) ? Number(calFactor).toFixed(2) : '—';
                    setTextIfChanged(calFactorEl, shown);
                }
            }
            if (typeof msg.cloud === 'string' || typeof msg.cloud === 'boolean') {
                setCloudStatus(msg.cloud);
            }
            if (typeof msg.apiKey === 'string') {
                const nextKey = msg.apiKey || '';
                if (apiKey !== nextKey) {
                    apiKey = nextKey;
                    const input = document.getElementById('newApiKey');
                    if (input && input.value !== apiKey) input.value = apiKey;
                }
            }
        }
    };
}

// Envoie une requête pour mettre à jour la clé API sur le serveur
function updateApiKey() {
    const btn = event && event.target ? event.target : document.querySelector('button[onclick="updateApiKey()"]');
    const input = document.getElementById('newApiKey');
    const newKey = (input && input.value ? input.value.trim() : '');
    if (!newKey) { alert('Please enter a valid API key.'); return; }

    // Optional: show a short pending state on the button
    if (btn) { btn.disabled = true; btn.textContent = 'Verifying…'; }

    if (ws && ws.readyState === WebSocket.OPEN) {
        // Send key to firmware; firmware will validate and reply with {type:'apiStatus', valid, displayName}
        ws.send(JSON.stringify({ type: 'updateApiKey', value: newKey }));
    } else {
        alert('WebSocket not connected. Please reload the page.');
    }

    // Re-enable the button shortly; final status will be reflected via apiStatus message
    setTimeout(() => { if (btn) { btn.disabled = false; btn.textContent = 'Update'; } }, 800);
}

// Envoie un poids manuel au serveur associé à l'UID courant
function sendWeight() {
    const manualWeight = parseInt(document.getElementById('manualWeight').value, 10);
    if (isNaN(manualWeight)) {
        alert('Please enter a valid integer weight.');
        return;
    }
    if (!currentUid) {
        alert('No UID detected. Cannot send weight.');
        return;
    }
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'sendWeight', weight: manualWeight, uid: currentUid }));
    }
}

// Envoie une commande pour mettre la balance à zéro (tare)
function tareScale() {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'tare' }));
    }
}

// Envoie une nouvelle valeur de facteur de calibration au serveur
function updateCalibration() {
    const newFactor = parseFloat(document.getElementById('newCalFactor').value);
    if (isNaN(newFactor)) {
        alert('Please enter a valid calibration factor.');
        return;
    }
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'updateCalFactor', value: newFactor }));
    }
}

// Calcule un nouveau facteur de calibration basé sur un poids connu et la lecture actuelle
function computeFactor() {
    const knownWeight = parseFloat(document.getElementById('knownWeight').value);
    if (isNaN(knownWeight) || knownWeight <= 0) {
        alert('Please enter a valid known weight greater than zero.');
        return;
    }
    if (currentWeight === null || calFactor === null) {
        alert('Current weight or calibration factor not available.');
        return;
    }
    const newFactor = calFactor * (currentWeight / knownWeight);
    document.getElementById('newCalFactor').value = newFactor.toFixed(3);
}

// Envoie une commande pour réinitialiser la configuration Wi-Fi et redémarrer le portail captif
function resetWiFi() {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'resetWiFi' }));
    }
}

// Demande une réinitialisation d'usine après confirmation utilisateur
function factoryReset() {
    if (confirm('Are you sure you want to factory reset? This will erase all data.')) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'factoryReset' }));
        }
    }
}

// --- Polling HTTP local (1 Hz) : met à jour l'UI même si WS est down ---
// function applyStatusSnapshot(s) {
//     // weight
//     if (typeof s.weight !== 'undefined') {
//         weightEl.textContent = `${s.weight} g`;
//     }
//     // uid
//     if (typeof s.uid !== 'undefined') {
//         uidEl.textContent = s.uid || 'No tag detected';
//     }
//     // cloud
//     if (typeof s.cloud === 'string') {
//         setCloudStatus(s.cloud === 'ok' ? 'connected' : s.cloud);
//     }
//     // apiKey (si champ présent)
//     const apiInput = document.getElementById('newApiKey');
//     if (apiInput && typeof s.apiKey === 'string') {
//         apiInput.value = s.apiKey;
//     }
//     // calibration factor
//     if (typeof s.calibrationFactor !== 'undefined') {
//         const n = Number(s.calibrationFactor);
//         calFactorEl.textContent = isFinite(n) ? n.toFixed(2) : '—';
//     }
// }

// function pollStatusOnce() {
//     fetch('/api/status', { cache: 'no-store' })
//         .then(r => r.ok ? r.json() : Promise.reject(r.status))
//         .then(applyStatusSnapshot)
//         .catch(() => {});
// }

// Try to pull current apiKey from device and validate once at load
fetch('/api/status', { cache: 'no-store' })
  .then(r => r.ok ? r.json() : Promise.reject(r.status))
  .then(s => { if (s && typeof s.apiKey === 'string') { apiKey = s.apiKey; const inp = document.getElementById('newApiKey'); if (inp && inp.value !== apiKey) inp.value = apiKey; /* validation is handled by firmware via WS */ } })
  .catch(() => {});

window.onload = () => {
    connectWs();            // temps réel via WS
//    pollStatusOnce();       // snapshot immédiat
//    setInterval(pollStatusOnce, 1000); // mise à jour 1 Hz
};
</script>
</body>
</html>